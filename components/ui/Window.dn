data VC{
	char result[]
	}

library interface UIPlaneLib{
	int makeWindow()
	
	void startPoly()
	void addPolyPoint(int x, int y, byte r, byte g, byte b, byte a)
	void endPoly()
	
	void addRect(int phandle, int x, int y, int w, int h, byte r, byte g, byte b, byte a)
	
	void addLine(int phandle, int sx, int sy, int ex, int ey, byte r, byte g, byte b, byte a)
	
	void addPoint(int phandle, int x, int y, byte r, byte g, byte b, byte a)
	void addBitmap(int phandle, Bitmap pixels, int x, int y)
	
	void addText(int phandle, int x, int y, char text[], byte r, byte g, byte b, byte a)
	void addTextWith(int phandle, int fontHandle, int x, int y, char text[], byte r, byte g, byte b, byte a)
	
	void pushSurface(int phandle, int x, int y, int w, int h, int sx, int sy)
	void popSurface(int phandle)
	
	void setSize(int phandle, int x, int y)

	void setPosition(int phandle, int x, int y)
	
	void setVisible(int phandle, bool b)
	
	void setTitle(int phandle, char t[])
	
	void commitBuffer(int phandle)
	
	void registerClickListener(int phandle, XYClickListener cl)
	void registerMouseListener(int phandle, XYMouseListener cl)
	
	void setBackgroundColor(int phandle, byte r, byte g, byte b, byte a)
	
	void maximiseWindow(int phandle)
	void minimiseWindow(int phandle)
	
	void getMaximisedScreenRect(int phandle, Rect r)
	
	void closeWindow(int phandle)
	
	// -- fonts --
	int loadFont(char path[], int size)
	int getTextWidth(int phandle, char text[])
	void getFontMetrics(int phandle, FontMetrics metrics)
	void getFontName(int phandle, VC result)
	bool isFontFixedWidth(int phandle)
	void getTextBitmapWith(int phandle, char text[], Bitmap pixels, byte r, byte g, byte b, byte a)
	}

data XYListener{
	XYMouseListener object
	XYListener next
	XYListener prev
	}

data GraphicsItem{
	GraphicsObject object
	GraphicsItem next
	GraphicsItem prev
	}

data ClickableItem{
	ClickableObject object
	ClickableItem next
	ClickableItem prev
	}

component provides Window(XYClickListener, XYMouseListener, TitleBarEventListener), Font, Service requires NativeLoader inl, TitleBar, io.Output out, data.IntUtil iu
	{
	static library UIPlaneLib lib
	
	implementation Window{
		GraphicsItem buffer
		GraphicsItem bufferEnd
		
		ClickableItem clickItems
		ClickableItem clickItemsEnd
		
		Mutex mouseListenerLock
		XYListener mouseListeners
		XYListener mouseListenersEnd
		
		TitleBar titleBar
		
		Mutex windowStateLock
		
		int currentX = 100
		int currentY = 80
		
		int currentWidth = 500
		int currentHeight = 500
		
		int platformHandle
		
		bool isMaximised
		int restoredWidth
		int restoredHeight
		int restoredX
		int restoredY
		
		Color borderColor = new Color(190, 190, 200, 255)
		
		Window:Window(char title[])
			{
			platformHandle = lib.makeWindow()
			if (platformHandle == 0) throw new Exception("Platform window creation failed")
			
			lib.setTitle(platformHandle, title)
			
			titleBar = new TitleBar(title)
			
			titleBar.setWindow(this)
			
			titleBar.addEventListener(this)
			
			lib.registerClickListener(platformHandle, this)
			lib.registerMouseListener(platformHandle, this)
			}
		
		void Window:setVisible(bool b)
			{
			mutex(windowStateLock)
				{
				lib.setVisible(platformHandle, b)
				}
			}
		
		void Window:setTitle(char title[])
			{
			mutex(windowStateLock)
				{
				lib.setTitle(platformHandle, title)
				titleBar.setTitle(title)
				}
			}
		
		void Window:close()
			{
			mutex(windowStateLock)
				{
				lib.closeWindow(platformHandle)
				platformHandle = 0
				}
			}
		
		void Window:repaint()
			{
			drawRectOutline(new Rect2D(0, 0, currentWidth, currentHeight, borderColor))
			
			if (titleBar != null) titleBar.paint(this)
			
			for (GraphicsItem bi = buffer; bi != null; bi = bi.next)
				{
				while (bi != null && bi.object == null)
					{
					GraphicsItem td = bi
					bi = bi.next
					
					if (td.prev == null)
						buffer = td.next
						else
						td.prev.next = td.next
					
					if (td.next == null)
						bufferEnd = td.prev
						else
						td.next.prev = td.prev
					}
				
				if (bi != null) bi.object.paint(this)
				}
			
			mutex(windowStateLock)
				{
				lib.commitBuffer(platformHandle)
				}
			}
		
		void Window:addObject(GraphicsObject go)
			{
			GraphicsItem newItem = new GraphicsItem(go)
			
			if (buffer == null)
				buffer = newItem
				else
				bufferEnd.next = newItem
			
			newItem.prev = bufferEnd
			bufferEnd = newItem
			
			go.setPanel(this)
			repaint()
			}
		
		void Window:remObject(GraphicsObject go)
			{
			for (GraphicsItem bi = buffer; bi != null; bi = bi.next)
				{
				if (bi.object === go)
					{
					GraphicsItem td = bi
					
					if (td.prev == null)
						buffer = td.next
						else
						td.prev.next = td.next
					
					if (td.next == null)
						bufferEnd = td.prev
						else
						td.next.prev = td.prev
					
					remClickTarget(go)
					
					break
					}
				}
			
			repaint()
			}
		
		GraphicsObjectItem[] Window:getObjects()
			{
			return null
			}
		
		void Window:addClickTarget(ClickableObject co)
			{
			ClickableItem nci = new ClickableItem(co)
			
			if (clickItems == null)
				clickItems = nci
				else
				clickItemsEnd.next = nci
			
			nci.prev = clickItemsEnd
			clickItemsEnd = nci
			}
		
		void Window:remClickTarget(ClickableObject o)
			{
			for (ClickableItem ci = clickItems; ci != null; ci = ci.next)
				{
				if (ci.object === o)
					{
					ClickableItem td = ci
					
					if (td.prev == null)
						clickItems = td.next
						else
						td.prev.next = td.next
					
					if (td.next == null)
						clickItemsEnd = td.prev
						else
						td.next.prev = td.prev
					
					break
					}
				}
			}
		
		ClickableObjectItem[] Window:getClickTargets()
			{
			return null
			}
		
		void Window:addCloseListener(CloseEventListener el)
			{
			titleBar.addCloseListener(el)
			}
		
		void Window:drawRect(Rect2D r)
			{
			mutex(windowStateLock)
				{
				lib.addRect(platformHandle, r.x, r.y, r.width, r.height, r.color.r, r.color.g, r.color.b, r.color.a)
				}
			}
		
		void Window:drawRectOutline(Rect2D r)
			{
			drawLine(new Line2D(r.x, r.y, (r.x + r.width) - 1, r.y, r.color))
			drawLine(new Line2D(r.x, r.y, r.x, (r.y + r.height) - 1, r.color))
			drawLine(new Line2D((r.x + r.width) - 1, r.y, (r.x + r.width) - 1, (r.y + r.height) - 1, r.color))
			drawLine(new Line2D(r.x, (r.y + r.height) - 1, (r.x + r.width) - 1, (r.y + r.height) - 1, r.color))
			}
		
		void Window:drawLine(Line2D l)
			{
			mutex(windowStateLock)
				{
				lib.addLine(platformHandle, l.sx, l.sy, l.ex, l.ey, l.color.r, l.color.g, l.color.b, l.color.a)
				}
			}
		
		void Window:drawPoint(Point2D p)
			{
			mutex(windowStateLock)
				{
				lib.addPoint(platformHandle, p.x, p.y, p.color.r, p.color.g, p.color.b, p.color.a)
				}
			}
		
		void Window:drawBitmap(Bitmap map, int x, int y)
			{
			mutex(windowStateLock)
				{
				lib.addBitmap(platformHandle, map, x, y)
				}
			}
		
		void Window:drawText(Point2D origin, Font f, char text[])
			{
			//check if f is implemented by this component and if so we use its internal font handle; otherwise we fall back on Font.getBitmap() (which is slow)
			mutex(windowStateLock)
				{
				if (this implements f)
					lib.addTextWith(platformHandle, f.platformHandle, origin.x, origin.y, text, origin.color.r, origin.color.g, origin.color.b, origin.color.a)
					else
					lib.addBitmap(platformHandle, f.getBitmap(text, origin.color), origin.x, origin.y)
				}
			}
		
		void Window:pushSurface(Rect rect, int xscr, int yscr)
			{
			mutex(windowStateLock)
				{
				lib.pushSurface(platformHandle, rect.x, rect.y, rect.width, rect.height, xscr, yscr)
				}
			}
		
		void Window:popSurface()
			{
			mutex(windowStateLock)
				{
				lib.popSurface(platformHandle)
				}
			}
		
		void Window:addXYMouseListener(XYMouseListener ml)
			{
			mutex(mouseListenerLock){
				XYListener nl = new XYListener(ml)
				
				if (mouseListeners == null)
					mouseListeners = nl
					else
					mouseListenersEnd.next = nl
				
				nl.prev = mouseListenersEnd
				mouseListenersEnd = nl
				}
			}
		
		void Window:setPosition(int x, int y)
			{
			mutex(windowStateLock)
				{
				currentX = x
				currentY = y
				lib.setPosition(platformHandle, x, y)
				}
			}
		
		void Window:setSize(int x, int y)
			{
			mutex(windowStateLock)
				{
				currentWidth = x
				currentHeight = y
				lib.setSize(platformHandle, x, y)
				}
			
			repaint()
			}
		
		WH Window:getSize()
			{
			return new WH(currentWidth, currentHeight)
			}
		
		void TitleBarEventListener:maximiseEvent()
			{
			if (isMaximised)
				{
				setPosition(restoredX, restoredY)
				setSize(restoredWidth, restoredHeight)
				
				isMaximised = false
				}
				else
				{
				restoredWidth = currentWidth
				restoredHeight = currentHeight
				
				restoredX = currentX
				restoredY = currentY
				
				Rect r = new Rect()
				mutex(windowStateLock)
					{
					lib.getMaximisedScreenRect(platformHandle, r)
					}
				
				setPosition(r.x, r.y)
				setSize(r.width, r.height)
				
				isMaximised = true
				}
			}
		
		void TitleBarEventListener:minimiseEvent()
			{
			mutex(windowStateLock)
				{
				lib.minimiseWindow(platformHandle)
				}
			}
		
		Rect Window:getRect()
			{
			return new Rect(currentX, currentY, currentWidth, currentHeight)
			}
		
		Point Window:getPosition()
			{
			return new Point(currentX, currentY)
			}
		
		void Window:setBackground(Color c)
			{
			mutex(windowStateLock)
				{
				lib.setBackgroundColor(platformHandle, c.r, c.g, c.b, c.a)
				}
			}
		
		Color Window:getBackground()
			{
			return null
			}
		
		void XYClickListener:click(int x, int y, int button)
			{
			for (ClickableItem ci = clickItems; ci != null; ci = ci.next)
				{
				while (ci != null && ci.object == null)
					{
					ClickableItem td = ci
					ci = ci.next
					
					if (td.prev == null)
						clickItems = td.next
						else
						td.prev.next = td.next
					
					if (td.next == null)
						clickItemsEnd = td.prev
						else
						td.next.prev = td.prev
					}
				
				if (ci != null)
					{
					Rect r = ci.object.getBounds()
					
					if (x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height)
						{
						ci.object.click(x, y, button)
						break
						}
					}
				}
			}
		
		void XYMouseListener:mouseDown(int x, int y, int button)
			{
			mutex(mouseListenerLock){
				for (XYListener mi = mouseListeners; mi != null; mi = mi.next)
					{
					while (mi != null && mi.object == null)
						{
						XYListener td = mi
						mi = mi.next
						
						if (td.prev == null)
							mouseListeners = td.next
							else
							td.prev.next = td.next
						
						if (td.next == null)
							mouseListenersEnd = td.prev
							else
							td.next.prev = td.prev
						}
					
					if (mi != null) mi.object.mouseDown(x, y, button)
					}
				}
			}
		
		void XYMouseListener:mouseUp(int x, int y, int button)
			{
			mutex(mouseListenerLock){
				for (XYListener mi = mouseListeners; mi != null; mi = mi.next)
					{
					while (mi != null && mi.object == null)
						{
						XYListener td = mi
						mi = mi.next
						
						if (td.prev == null)
							mouseListeners = td.next
							else
							td.prev.next = td.next
						
						if (td.next == null)
							mouseListenersEnd = td.prev
							else
							td.next.prev = td.prev
						}
					
					if (mi != null) mi.object.mouseUp(x, y, button)
					}
				}
			}
		
		void XYMouseListener:mouseMove(int x, int y)
			{
			mutex(mouseListenerLock){
				for (XYListener mi = mouseListeners; mi != null; mi = mi.next)
					{
					while (mi != null && mi.object == null)
						{
						XYListener td = mi
						mi = mi.next
						
						if (td.prev == null)
							mouseListeners = td.next
							else
							td.prev.next = td.next
						
						if (td.next == null)
							mouseListenersEnd = td.prev
							else
							td.next.prev = td.prev
						}
					
					if (mi != null) mi.object.mouseMove(x, y)
					}
				}
			}
		
		void Window:setPanel(Panel p)
			{
			}
		
		Panel Window:getPanel()
			{
			return null
			}
		
		void Window:paint(Canvas c)
			{
			}
		
		WH Window:getPreferredSize()
			{
			return new WH(currentWidth, currentHeight)
			}
		
		Rect Window:getBounds()
			{
			return new Rect(0, 0, currentWidth, currentHeight)
			}
		
		void Window:addClickListener(ClickListener cl){}
		void Window:remClickListener(ClickListener cl){}
		ClickListenerItem[] Window:getClickListeners(){return null}
		
		void Window:click(int x, int y, int button){}
		}
	
	implementation Font{
		int platformHandle
		
		Font:Font(char path[], int size)
			{
			platformHandle = lib.loadFont(path, size)
			
			if (platformHandle == 0) throw new Exception("Failed to load font $path")
			}
		
		FontMetrics Font:getFontMetrics()
			{
			FontMetrics result = new FontMetrics()
			lib.getFontMetrics(platformHandle, result)
			return result
			}
		
		char[] Font:getFontName()
			{
			VC result = new VC()
			lib.getFontName(platformHandle, result)
			return result.result
			}
		
		bool Font:isFixedCharacterWidth()
			{
			return lib.isFontFixedWidth(platformHandle)
			}
		
		int Font:getTextWidth(char text[])
			{
			return lib.getTextWidth(platformHandle, text)
			}
		
		Bitmap Font:getBitmap(char string[], Color textColor)
			{
			Bitmap result = new Bitmap(new WH())
			lib.getTextBitmapWith(platformHandle, string, result, textColor.r, textColor.g, textColor.b, textColor.a)
			return result
			}
		}
	
	implementation Service{
		void Service:start()
			{
			lib = new UIPlaneLib() from inl.load("uiplane") :< UIPlaneLib
			}
		
		void Service:stop()
			{
			}
		}
	}