//magic header of a Dana object matching the below format
const byte danaMagic[] = new int[](0x44, 0x41, 0x4E, 0x41, 0x0, 0x1)

//a Dana object header
record SourceHeader{
	//basic identification; this part is always the same total size
	byte magic[6]
	byte checksum[4]
	byte objectType[2]
	byte hostType[2]
	byte vpuType[2]
	//the below fields are each the size of the target host machine's native address width
	//machine code
	int textOffset
	int textSize
	//local relocations; a list of addresses to add the start address of this object to
	int lrTableOffset
	int lrTableSize
	int lrTableCount
	//info sections (if one of these is hardlinks then this object file is not fit to be loaded)
	int infoSectionsOffset
	int infoSectionsSize
	int infoSectionsCount
	}

//a Dana object relocation record
record Relocation{
	int offset
	}

//an info section header
record InfoSection{
	byte sectionType[4] //type code identifying the section's purpose (0.x.x.x, D.N.x.x, F.R.x.x are reserved)
	byte contentType[4] //type code identifying the kind of content (json, xml, jpeg, etc.)
	int size //size of the section's content, excluding this header
	}

data LoadedComponent{
	byte text[]
	IDC com
	
	LoadedComponent next
	}

component provides composition.Loader requires io.File, io.Output out, data.IntUtil iu, System system {
	
	LoadedComponent components
	LoadedComponent lastComponent
	
	byte[] readSubArray(byte ofArray[], int start, int length)
		{
		byte result[] = new byte[length]
		
		for (int i = 0; i < length; i++)
			result[i] = ofArray[start+i]
		
		return result
		}
	
	void writeSubArray(byte toArray[], int start, byte fromArray[])
		{
		for (int i = 0; i < fromArray.arrayLength; i++)
			{
			toArray[start+i] = fromArray[i]
			}
		}
	
	//this function returns an "IDC" - a generic Dana component interface
	IDC Loader:load(char file[])
		{
		File fd = new File(file, File.FILE_ACCESS_READ)
		
		if (fd == null)
			return null
		
		SourceHeader hdr
		byte serialHDR[] = dana.getByteArrayOf(hdr)
		
		byte buf[]
		
		if ((buf = fd.read(serialHDR.arrayLength)).arrayLength != serialHDR.arrayLength)
			{
			out.println("Error: File is not a Dana object")
			return null
			}
		
		serialHDR =[] buf
		
		if (hdr.magic != danaMagic)
			{
			out.println("Error: File is not a Dana object")
			return null
			}
		
		if (hdr.hostType != system.getHostType())
			{
			out.println("Error: File was compiled for a different architecture")
			return null
			}
		
		if (hdr.vpuType != system.getVMType())
			{
			out.println("Error: File was compiled for a different VPU version")
			return null
			}
		
		LoadedComponent nc = new LoadedComponent()
		
		// -- load program text (i.e. machine code) --
		
		fd.setPos(hdr.textOffset)
		
		nc.text = clone fd.read(hdr.textSize)
		
		// -- perform relocations --
		fd.setPos(hdr.lrTableOffset)
		
		for (int i = 0; i < hdr.lrTableCount; i++)
			{
			byte serialData[]
			
			Relocation r
			serialData = dana.getByteArrayOf(r)
			serialData =[] fd.read(serialData.arrayLength)
			
			int addr
			serialData = dana.getByteArrayOf(addr)
			serialData =[] readSubArray(nc.text, r.offset, serialData.arrayLength)
			
			//addresses within program text are stored in host format, so we convert:
			addr = dana.htod(addr)
			addr += dana.getAddressOf(nc.text) //we add the memory start address of nc.text
			addr = dana.dtoh(addr)
			
			writeSubArray(nc.text, r.offset, serialData)
			}
		
		fd.close()
		
		nc.com = dana.load(nc.text)
		
		if (components == null)
			components = nc
			else
			lastComponent.next = nc
		lastComponent = nc
		
		serialHDR = null
		
		return nc.com
		}
	
	void Loader:unload(IDC com)
		{
		LoadedComponent lc = components
		LoadedComponent prevLC
		
		while (lc != null)
			{
			if (lc.com == com)
				{
				dana.unload(lc.com)
				
				if (prevLC == null)
					components = lc.next
					else
					prevLC.next = lc.next
				
				if (lastComponent == lc) lastComponent = prevLC
				
				return
				}
			
			prevLC = lc
			lc = lc.next
			}
		}
	}